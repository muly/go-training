# interface

////////////////////////////////////////////////////////////////////////
## what is an interface
- abstraction of functionality
- describes "what" but not "how"
- describes the methods' signature but not the implementation/body

: interface describes "what" but not "how" part of the functionality. it is up to the implementor of the interface to describe "how" part.



## real life examples
- usb type c port
- standard power outlet
- ATM machine



## interface syntax

    type <interface name> interface{
        <method-signature>
        ........
    }



## interface example

    type shape interface {
        area() float32
        perimeter() float32
    }


////////////////////////////////////////////////////////////////////////
## implementing an interface 


## implementing an interface 
**basic interface implementation example**

.play -numbers _concepts/09_interfaces/00a.go /START OMIT/,/END OMIT/


## implementing an interface 
**basic interface implementation example**

continued... 

.play -numbers _concepts/09_interfaces/00a.go /^func main/,/^}/
: we declare the variable of type interface, but initialize it with a concrete type that implements the interface

: square implements shape interface, because square has the area() and perimeter() methods implemented (with the same signature as in the interface definition).


## implementing an interface 
**interface implementation must be done by a user defined types, but not system type**

: we cannot use built-in types to implement an interface, because we cannot add methods on a system type like string
: the code in this example attempts to implement an interface by a built-in type

incorrect example

.play -numbers _concepts/09_interfaces/00b.go /START OMIT/,/END OMIT/


## implementing an interface 
**interface implementation must be done by a user defined types, but not system type**

correct example

.play -numbers _concepts/09_interfaces/00b2.go /START OMIT/,/END OMIT/


## implementing an interface 
**interface implementation must be done by a user defined types, but not system type**

correct example

.play -numbers _concepts/09_interfaces/00b3.go /START OMIT/,/END OMIT/




## implementing an interface 
**user defined type implementing an interface must have all the methods defined by the interface**

.play -numbers _concepts/09_interfaces/00c.go /START OMIT/,/END OMIT/



## implementing an interface 
**a user defined type implementing an interface can have extra methods other than those defined by the interface**

: in this example the type square have an extra method called `getColor()` which is not part of the interface definition

.play -numbers _concepts/09_interfaces/00d.go /START OMIT/,/END OMIT/

## implementing an interface 
**a user defined type implementing an interface can have extra methods other than those defined by the interface**

continued... 

.play -numbers _concepts/09_interfaces/00d.go /^func main/,/^}/




## implementing an interface 
**an interface can be implemented by more than one type**
, 00e.go => 01.go

////////////////////////////////////////////////////////////////////////



## implementing an interface 
**Nil interface value**

.play -numbers _concepts/09_interfaces/00f.go /START OMIT/,/END OMIT/


## implementing an interface 
**Nil interface value**

continued

.play -numbers _concepts/09_interfaces/00f.go /^func main/,/^}/


## implementing an interface 
**an type can implement more than one interface**

.play -numbers _concepts/09_interfaces/02.go /START OMIT/,/END OMIT/

## implementing an interface 
**an type can implement more than one interface**

continued

.play -numbers _concepts/09_interfaces/02.go /^func main/,/^}/

: even though the getColor() is a method on the "square" type, it cannot be accessed using the "shape" interface type variable.



////////////////////////////////////////////////////////////////////////
## single method interfaces

## single method interfaces
**significance**
// TODO: 

## single method interfaces
**example built in Go**

*stringer*

    type stringer interface {
        String() string
    }

*error*

    type error interface {
        Error() string
    }


////////////////////////////////////////////////////////////////////////
## interface type %T and interface values


## interface type %T and interface values


// .code _concepts/09_interfaces/03.go /^type square/,/^}/
.play -numbers _concepts/09_interfaces/03.go /^func main/,/^}/



////////////////////////////////////////////////////////////////////////
## function with interface type as a parameter

.play -numbers _concepts/09_interfaces/04.go /START OMIT/,/END OMIT/

## function with interface type as a parameter
continued

// TODO: add notes that the below functions are bad to have, instead create a function that takes interface type

    func describeSquare(s square) {
        fmt.Printf("I'm a square, with data %+v\n", s)
    }
    func describeRectangle(s rectangle) {
        fmt.Printf("I'm a rectangle, with data %+v\n", s)
    }

.code -numbers _concepts/09_interfaces/04.go /^func describeShape/,/^}/

## function with interface type as a parameter
continued

.play -numbers _concepts/09_interfaces/04.go /^func main/,/^}/


////////////////////////////////////////////////////////////////////////
## empty interface

## empty interface
**2 method interface**

    type shape interface {
        area() float32
        perimeter() float32
    }

    type square struct {
        length float32
    }

    func (s square) area() float32 {
        return s.length * s.length
    }
    func (s square) perimeter() float32 {
        return s.length * 4
    }

implementing type must have those 2 matching methods


## empty interface
**single method interface**

    type printer interface {
        print(string)
    }

    type canon struct {
        name string
    }

    func (c canon) print(s string) {
        fmt.Println(s)
    }


implementing type must have those 1 matching method


## empty interface
**0 method interface, aka empty interface**

    type empty interface {
        // Note: no methods
    }

implementing type must have 0 matching method,

i.e all types will implement it

: 05a.go show the complete code if needed

## empty interface

	type empty interface{} 
	var a empty
	
or 

	var a interface{} // No need to define a type for empty interface


## empty interface
**example**

.code -numbers _concepts/09_interfaces/05b.go /START OMIT/,/END OMIT/

## empty interface
**example**

continued

.play -numbers _concepts/09_interfaces/05b.go  /^func main/,/^}/



## empty interface
**function with a parameter of type empty interface**

.play -numbers _concepts/09_interfaces/05c.go /START OMIT/,/END OMIT/

////////////////////////////////////////////////////////////////////////
## type assertions

## type assertions
**type casting: lets look into type casting first**

.play -numbers _concepts/09_interfaces/06a.go /START OMIT/,/END OMIT/


## type assertions
06b.go

## type switch
06c.go type switch
06d.go another type switch example by using value returned by type switch


////////////////////////////////////////////////////////////////////////
## quiz

1) does this implement?
type shape interface {
	color(a string) string
}
type square struct {
}
func (s square) color(b string) string {
	return "hello "
}


2) does this implement?
type shape interface {
	color(string) string
}
type square struct {
}
func (s square) color(b string) string {
	return "hello "
}
